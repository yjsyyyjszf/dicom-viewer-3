{"ast":null,"code":"/*! cornerstone-math - 0.1.8 - 2019-01-16 | (c) 2017 Chris Hafey | https://github.com/cornerstonejs/cornerstoneMath */\n!function (t, e) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define(\"cornerstone-math\", [], e) : \"object\" == typeof exports ? exports[\"cornerstone-math\"] = e() : t.cornerstoneMath = e();\n}(window, function () {\n  return function (t) {\n    var e = {};\n\n    function i(n) {\n      if (e[n]) return e[n].exports;\n      var o = e[n] = {\n        i: n,\n        l: !1,\n        exports: {}\n      };\n      return t[n].call(o.exports, o, o.exports, i), o.l = !0, o.exports;\n    }\n\n    return i.m = t, i.c = e, i.d = function (t, e, n) {\n      i.o(t, e) || Object.defineProperty(t, e, {\n        configurable: !1,\n        enumerable: !0,\n        get: n\n      });\n    }, i.r = function (t) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      });\n    }, i.n = function (t) {\n      var e = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return i.d(e, \"a\", e), e;\n    }, i.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, i.p = \"\", i(i.s = 9);\n  }([function (t, e, i) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.clamp = function (t, e, i) {\n      return t < e ? e : t > i ? i : t;\n    }, e.degToRad = function (t) {\n      return t * (Math.PI / 180);\n    }, e.radToDeg = function (t) {\n      return t * (180 / Math.PI);\n    }, e.sign = function (t) {\n      return \"number\" == typeof t ? t ? t < 0 ? -1 : 1 : t == t ? 0 : NaN : NaN;\n    };\n  }, function (t, e, i) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n    var n,\n        o = i(3),\n        s = (n = o) && n.__esModule ? n : {\n      default: n\n    },\n        r = i(0);\n\n    var a,\n        h,\n        u,\n        c,\n        l,\n        f = function (t, e, i) {\n      this.x = t || 0, this.y = e || 0, this.z = i || 0;\n    };\n\n    f.prototype = {\n      constructor: f,\n      set: function (t, e, i) {\n        return this.x = t, this.y = e, this.z = i, this;\n      },\n      setX: function (t) {\n        return this.x = t, this;\n      },\n      setY: function (t) {\n        return this.y = t, this;\n      },\n      setZ: function (t) {\n        return this.z = t, this;\n      },\n      setComponent: function (t, e) {\n        switch (t) {\n          case 0:\n            this.x = e;\n            break;\n\n          case 1:\n            this.y = e;\n            break;\n\n          case 2:\n            this.z = e;\n            break;\n\n          default:\n            throw new Error(\"index is out of range: \" + t);\n        }\n      },\n      getComponent: function (t) {\n        switch (t) {\n          case 0:\n            return this.x;\n\n          case 1:\n            return this.y;\n\n          case 2:\n            return this.z;\n\n          default:\n            throw new Error(\"index is out of range: \" + t);\n        }\n      },\n      copy: function (t) {\n        return this.x = t.x, this.y = t.y, this.z = t.z, this;\n      },\n      add: function (t, e) {\n        return void 0 !== e ? (console.warn(\"DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this);\n      },\n      addScalar: function (t) {\n        return this.x += t, this.y += t, this.z += t, this;\n      },\n      addVectors: function (t, e) {\n        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;\n      },\n      sub: function (t, e) {\n        return void 0 !== e ? (console.warn(\"DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this);\n      },\n      subVectors: function (t, e) {\n        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;\n      },\n      multiply: function (t, e) {\n        return void 0 !== e ? (console.warn(\"DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.\"), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this);\n      },\n      multiplyScalar: function (t) {\n        return this.x *= t, this.y *= t, this.z *= t, this;\n      },\n      multiplyVectors: function (t, e) {\n        return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;\n      },\n      applyAxisAngle: (l = void 0, function (t, e) {\n        return void 0 === l && (l = new s.default()), this.applyQuaternion(l.setFromAxisAngle(t.normalize(), e)), this;\n      }),\n      applyMatrix3: function (t) {\n        var e = this.x,\n            i = this.y,\n            n = this.z,\n            o = t.elements;\n        return this.x = o[0] * e + o[3] * i + o[6] * n, this.y = o[1] * e + o[4] * i + o[7] * n, this.z = o[2] * e + o[5] * i + o[8] * n, this;\n      },\n      applyMatrix4: function (t) {\n        var e = this.x,\n            i = this.y,\n            n = this.z,\n            o = t.elements;\n        return this.x = o[0] * e + o[4] * i + o[8] * n + o[12], this.y = o[1] * e + o[5] * i + o[9] * n + o[13], this.z = o[2] * e + o[6] * i + o[10] * n + o[14], this;\n      },\n      applyProjection: function (t) {\n        var e = this.x,\n            i = this.y,\n            n = this.z,\n            o = t.elements,\n            s = 1 / (o[3] * e + o[7] * i + o[11] * n + o[15]);\n        return this.x = (o[0] * e + o[4] * i + o[8] * n + o[12]) * s, this.y = (o[1] * e + o[5] * i + o[9] * n + o[13]) * s, this.z = (o[2] * e + o[6] * i + o[10] * n + o[14]) * s, this;\n      },\n      applyQuaternion: function (t) {\n        var e = this.x,\n            i = this.y,\n            n = this.z,\n            o = t.x,\n            s = t.y,\n            r = t.z,\n            a = t.w,\n            h = a * e + s * n - r * i,\n            u = a * i + r * e - o * n,\n            c = a * n + o * i - s * e,\n            l = -o * e - s * i - r * n;\n        return this.x = h * a + l * -o + u * -r - c * -s, this.y = u * a + l * -s + c * -o - h * -r, this.z = c * a + l * -r + h * -s - u * -o, this;\n      },\n      transformDirection: function (t) {\n        var e = this.x,\n            i = this.y,\n            n = this.z,\n            o = t.elements;\n        return this.x = o[0] * e + o[4] * i + o[8] * n, this.y = o[1] * e + o[5] * i + o[9] * n, this.z = o[2] * e + o[6] * i + o[10] * n, this.normalize(), this;\n      },\n      divide: function (t) {\n        return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;\n      },\n      divideScalar: function (t) {\n        if (0 !== t) {\n          var e = 1 / t;\n          this.x *= e, this.y *= e, this.z *= e;\n        } else this.x = 0, this.y = 0, this.z = 0;\n\n        return this;\n      },\n      min: function (t) {\n        return this.x > t.x && (this.x = t.x), this.y > t.y && (this.y = t.y), this.z > t.z && (this.z = t.z), this;\n      },\n      max: function (t) {\n        return this.x < t.x && (this.x = t.x), this.y < t.y && (this.y = t.y), this.z < t.z && (this.z = t.z), this;\n      },\n      clamp: function (t, e) {\n        return this.x < t.x ? this.x = t.x : this.x > e.x && (this.x = e.x), this.y < t.y ? this.y = t.y : this.y > e.y && (this.y = e.y), this.z < t.z ? this.z = t.z : this.z > e.z && (this.z = e.z), this;\n      },\n      clampScalar: (u = void 0, c = void 0, function (t, e) {\n        return void 0 === u && (u = new f(), c = new f()), u.set(t, t, t), c.set(e, e, e), this.clamp(u, c);\n      }),\n      floor: function () {\n        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;\n      },\n      ceil: function () {\n        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;\n      },\n      round: function () {\n        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;\n      },\n      roundToZero: function () {\n        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;\n      },\n      negate: function () {\n        return this.multiplyScalar(-1);\n      },\n      dot: function (t) {\n        return this.x * t.x + this.y * t.y + this.z * t.z;\n      },\n      lengthSq: function () {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n      },\n      length: function () {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n      },\n      lengthManhattan: function () {\n        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n      },\n      normalize: function () {\n        return this.divideScalar(this.length());\n      },\n      setLength: function (t) {\n        var e = this.length();\n        return 0 !== e && t !== e && this.multiplyScalar(t / e), this;\n      },\n      lerp: function (t, e) {\n        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;\n      },\n      cross: function (t, e) {\n        if (void 0 !== e) return console.warn(\"DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.\"), this.crossVectors(t, e);\n        var i = this.x,\n            n = this.y,\n            o = this.z;\n        return this.x = n * t.z - o * t.y, this.y = o * t.x - i * t.z, this.z = i * t.y - n * t.x, this;\n      },\n      crossVectors: function (t, e) {\n        var i = t.x,\n            n = t.y,\n            o = t.z,\n            s = e.x,\n            r = e.y,\n            a = e.z;\n        return this.x = n * a - o * r, this.y = o * s - i * a, this.z = i * r - n * s, this;\n      },\n      projectOnVector: (a = void 0, h = void 0, function (t) {\n        return void 0 === a && (a = new f()), a.copy(t).normalize(), h = this.dot(a), this.copy(a).multiplyScalar(h);\n      }),\n      projectOnPlane: function () {\n        var t = void 0;\n        return function (e) {\n          return void 0 === t && (t = new f()), t.copy(this).projectOnVector(e), this.sub(t);\n        };\n      }(),\n      reflect: function () {\n        var t = void 0;\n        return function (e) {\n          return void 0 === t && (t = new f()), this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)));\n        };\n      }(),\n      angleTo: function (t) {\n        var e = this.dot(t) / (this.length() * t.length());\n        return Math.acos((0, r.clamp)(e, -1, 1));\n      },\n      distanceTo: function (t) {\n        return Math.sqrt(this.distanceToSquared(t));\n      },\n      distanceToSquared: function (t) {\n        var e = this.x - t.x,\n            i = this.y - t.y,\n            n = this.z - t.z;\n        return e * e + i * i + n * n;\n      },\n      setFromMatrixPosition: function (t) {\n        return this.x = t.elements[12], this.y = t.elements[13], this.z = t.elements[14], this;\n      },\n      setFromMatrixScale: function (t) {\n        var e = this.set(t.elements[0], t.elements[1], t.elements[2]).length(),\n            i = this.set(t.elements[4], t.elements[5], t.elements[6]).length(),\n            n = this.set(t.elements[8], t.elements[9], t.elements[10]).length();\n        return this.x = e, this.y = i, this.z = n, this;\n      },\n      setFromMatrixColumn: function (t, e) {\n        var i = 4 * t,\n            n = e.elements;\n        return this.x = n[i], this.y = n[i + 1], this.z = n[i + 2], this;\n      },\n      equals: function (t) {\n        return t.x === this.x && t.y === this.y && t.z === this.z;\n      },\n      fromArray: function (t) {\n        return this.x = t[0], this.y = t[1], this.z = t[2], this;\n      },\n      toArray: function () {\n        return [this.x, this.y, this.z];\n      },\n      clone: function () {\n        return new f(this.x, this.y, this.z);\n      }\n    }, e.default = f;\n  }, function (t, e, i) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n    var n = i(0);\n\n    function o(t) {\n      return t * t;\n    }\n\n    function s(t, e) {\n      return o(t.x - e.x) + o(t.y - e.y);\n    }\n\n    var r = {\n      distanceToPoint: function (t, e) {\n        return Math.sqrt(function (t, e) {\n          var i = s(t.start, t.end);\n          if (0 === i) return s(e, t.start);\n          var n = ((e.x - t.start.x) * (t.end.x - t.start.x) + (e.y - t.start.y) * (t.end.y - t.start.y)) / i;\n          return s(e, n < 0 ? t.start : n > 1 ? t.end : {\n            x: t.start.x + n * (t.end.x - t.start.x),\n            y: t.start.y + n * (t.end.y - t.start.y)\n          });\n        }(t, e));\n      },\n      intersectLine: function (t, e) {\n        var i,\n            o,\n            s,\n            r,\n            a,\n            h,\n            u,\n            c,\n            l,\n            f,\n            y,\n            d = {},\n            p = t.start.x,\n            x = t.start.y,\n            m = t.end.x,\n            v = t.end.y,\n            g = e.start.x,\n            z = e.start.y,\n            b = e.end.x,\n            M = e.end.y,\n            w = void 0;\n\n        if (f = (i = v - x) * b + (s = p - m) * M + (a = m * x - p * v), (0 === (l = i * g + s * z + a) || 0 === f || (0, n.sign)(l) !== (0, n.sign)(f)) && (c = (o = M - z) * m + (r = g - b) * v + (h = b * z - g * M), 0 === (u = o * p + r * x + h) || 0 === c || (0, n.sign)(u) !== (0, n.sign)(c))) {\n          y = i * r - o * s, w = s * h - r * a;\n          var R = parseFloat(w / y);\n          w = o * a - i * h;\n          var P = parseFloat(w / y);\n          return d.x = R, d.y = P, d;\n        }\n      }\n    };\n    e.default = r;\n  }, function (t, e, i) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var n = function (t, e, i, n) {\n      this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1;\n    };\n\n    n.prototype.setFromAxisAngle = function (t, e) {\n      var i = e / 2,\n          n = Math.sin(i);\n      return this.x = t.x * n, this.y = t.y * n, this.z = t.z * n, this.w = Math.cos(i), this;\n    }, n.prototype.multiplyQuaternions = function (t, e) {\n      var i = t.x,\n          n = t.y,\n          o = t.z,\n          s = t.w,\n          r = e.x,\n          a = e.y,\n          h = e.z,\n          u = e.w;\n      return this.x = i * u + s * r + n * h - o * a, this.y = n * u + s * a + o * r - i * h, this.z = o * u + s * h + i * a - n * r, this.w = s * u - i * r - n * a - o * h, this;\n    }, n.prototype.setFromRotationMatrix = function (t) {\n      var e = t.elements,\n          i = e[0],\n          n = e[4],\n          o = e[8],\n          s = e[1],\n          r = e[5],\n          a = e[9],\n          h = e[2],\n          u = e[6],\n          c = e[10],\n          l = i + r + c,\n          f = void 0;\n      return l > 0 ? (f = .5 / Math.sqrt(l + 1), this.w = .25 / f, this.x = (u - a) * f, this.y = (o - h) * f, this.z = (s - n) * f) : i > r && i > c ? (f = 2 * Math.sqrt(1 + i - r - c), this.w = (u - a) / f, this.x = .25 * f, this.y = (n + s) / f, this.z = (o + h) / f) : r > c ? (f = 2 * Math.sqrt(1 + r - i - c), this.w = (o - h) / f, this.x = (n + s) / f, this.y = .25 * f, this.z = (a + u) / f) : (f = 2 * Math.sqrt(1 + c - i - r), this.w = (s - n) / f, this.x = (o + h) / f, this.y = (a + u) / f, this.z = .25 * f), this;\n    }, e.default = n;\n  }, function (t, e, i) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n    var n,\n        o = i(2),\n        s = (n = o) && n.__esModule ? n : {\n      default: n\n    };\n\n    function r(t) {\n      return {\n        topLeft: {\n          x: t.left,\n          y: t.top\n        },\n        bottomRight: {\n          x: t.left + t.width,\n          y: t.top + t.height\n        }\n      };\n    }\n\n    var a = {\n      distanceToPoint: function (t, e) {\n        var i = 655535;\n        return function (t) {\n          return [{\n            start: {\n              x: t.left,\n              y: t.top\n            },\n            end: {\n              x: t.left + t.width,\n              y: t.top\n            }\n          }, {\n            start: {\n              x: t.left + t.width,\n              y: t.top\n            },\n            end: {\n              x: t.left + t.width,\n              y: t.top + t.height\n            }\n          }, {\n            start: {\n              x: t.left + t.width,\n              y: t.top + t.height\n            },\n            end: {\n              x: t.left,\n              y: t.top + t.height\n            }\n          }, {\n            start: {\n              x: t.left,\n              y: t.top + t.height\n            },\n            end: {\n              x: t.left,\n              y: t.top\n            }\n          }];\n        }(t).forEach(function (t) {\n          var n = s.default.distanceToPoint(t, e);\n          n < i && (i = n);\n        }), i;\n      },\n      getIntersectionRect: function (t, e) {\n        var i = {\n          topLeft: {},\n          bottomRight: {}\n        };\n\n        if (function (t, e) {\n          var i = void 0,\n              n = void 0,\n              o = r(t),\n              s = r(e);\n          return i = t.width >= 0 ? e.width >= 0 ? !(o.bottomRight.x <= s.topLeft.x || s.bottomRight.x <= o.topLeft.x) : !(o.bottomRight.x <= s.bottomRight.x || s.topLeft.x <= o.topLeft.x) : e.width >= 0 ? !(o.topLeft.x <= s.topLeft.x || s.bottomRight.x <= o.bottomRight.x) : !(o.topLeft.x <= s.bottomRight.x || s.topLeft.x <= o.bottomRight.x), n = t.height >= 0 ? e.height >= 0 ? !(o.bottomRight.y <= s.topLeft.y || s.bottomRight.y <= o.topLeft.y) : !(o.bottomRight.y <= s.bottomRight.y || s.topLeft.y <= o.topLeft.y) : e.height >= 0 ? !(o.topLeft.y <= s.topLeft.y || s.bottomRight.y <= o.bottomRight.y) : !(o.topLeft.y <= s.bottomRight.y || s.top <= o.bottomRight.y), i && n;\n        }(t, e)) {\n          var n = r(t),\n              o = r(e);\n          return t.width >= 0 ? e.width >= 0 ? (i.topLeft.x = Math.max(n.topLeft.x, o.topLeft.x), i.bottomRight.x = Math.min(n.bottomRight.x, o.bottomRight.x)) : (i.topLeft.x = Math.max(n.topLeft.x, o.bottomRight.x), i.bottomRight.x = Math.min(n.bottomRight.x, o.topLeft.x)) : e.width >= 0 ? (i.topLeft.x = Math.min(n.topLeft.x, o.bottomRight.x), i.bottomRight.x = Math.max(n.bottomRight.x, o.topLeft.x)) : (i.topLeft.x = Math.min(n.topLeft.x, o.topLeft.x), i.bottomRight.x = Math.max(n.bottomRight.x, o.bottomRight.x)), t.height >= 0 ? e.height >= 0 ? (i.topLeft.y = Math.max(n.topLeft.y, o.topLeft.y), i.bottomRight.y = Math.min(n.bottomRight.y, o.bottomRight.y)) : (i.topLeft.y = Math.max(n.topLeft.y, o.bottomRight.y), i.bottomRight.y = Math.min(n.bottomRight.y, o.topLeft.y)) : e.height >= 0 ? (i.topLeft.y = Math.min(n.topLeft.y, o.bottomRight.y), i.bottomRight.y = Math.max(n.bottomRight.y, o.topLeft.y)) : (i.topLeft.y = Math.min(n.topLeft.y, o.topLeft.y), i.bottomRight.y = Math.max(n.bottomRight.y, o.bottomRight.y)), i;\n        }\n      }\n    };\n    e.default = a;\n  }, function (t, e, i) {\n    \"use strict\";\n\n    function n(t, e) {\n      return {\n        x: t.x - e.x,\n        y: t.y - e.y\n      };\n    }\n\n    function o(t, e) {\n      return Math.sqrt(s(t, e));\n    }\n\n    function s(t, e) {\n      var i = n(t, e);\n      return i.x * i.x + i.y * i.y;\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n    var r = {\n      subtract: n,\n      copy: function (t) {\n        return {\n          x: t.x,\n          y: t.y\n        };\n      },\n      pageToPoint: function (t) {\n        return {\n          x: t.pageX,\n          y: t.pageY\n        };\n      },\n      distance: o,\n      distanceSquared: s,\n      insideRect: function (t, e) {\n        return !(t.x < e.left || t.x > e.left + e.width || t.y < e.top || t.y > e.top + e.height);\n      },\n      findClosestPoint: function (t, e) {\n        var i = [],\n            n = void 0;\n        return t.forEach(function (t, s) {\n          var r = o(t, e);\n          i.push(r), n = 0 === s ? r : Math.min(r, n);\n        }), t[i.indexOf(n)];\n      }\n    };\n    e.default = r;\n  }, function (t, e, i) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n    var n,\n        o = i(1),\n        s = (n = o) && n.__esModule ? n : {\n      default: n\n    };\n\n    var r,\n        a,\n        h = function (t, e) {\n      this.normal = void 0 !== t ? t : new s.default(1, 0, 0), this.constant = void 0 !== e ? e : 0;\n    };\n\n    h.prototype = {\n      constructor: h,\n      set: function (t, e) {\n        return this.normal.copy(t), this.constant = e, this;\n      },\n      setComponents: function (t, e, i, n) {\n        return this.normal.set(t, e, i), this.constant = n, this;\n      },\n      setFromNormalAndCoplanarPoint: function (t, e) {\n        return this.normal.copy(t), this.constant = -e.dot(this.normal), this;\n      },\n      setFromCoplanarPoints: (r = new s.default(), a = new s.default(), function (t, e, i) {\n        var n = r.subVectors(i, e).cross(a.subVectors(t, e)).normalize();\n        return this.setFromNormalAndCoplanarPoint(n, t), this;\n      }),\n      copy: function (t) {\n        return this.normal.copy(t.normal), this.constant = t.constant, this;\n      },\n      normalize: function () {\n        var t = 1 / this.normal.length();\n        return this.normal.multiplyScalar(t), this.constant *= t, this;\n      },\n      negate: function () {\n        return this.constant *= -1, this.normal.negate(), this;\n      },\n      distanceToPoint: function (t) {\n        return this.normal.dot(t) + this.constant;\n      },\n      distanceToSphere: function (t) {\n        return this.distanceToPoint(t.center) - t.radius;\n      },\n      projectPoint: function (t, e) {\n        return this.orthoPoint(t, e).sub(t).negate();\n      },\n      orthoPoint: function (t, e) {\n        var i = this.distanceToPoint(t);\n        return (e || new s.default()).copy(this.normal).multiplyScalar(i);\n      },\n      isIntersectionLine: function (t) {\n        var e = this.distanceToPoint(t.start),\n            i = this.distanceToPoint(t.end);\n        return e < 0 && i > 0 || i < 0 && e > 0;\n      },\n      intersectLine: function () {\n        var t = new s.default();\n        return function (e, i) {\n          var n = i || new s.default(),\n              o = e.delta(t),\n              r = this.normal.dot(o);\n          if (0 === r) return 0 === this.distanceToPoint(e.start) ? n.copy(e.start) : void 0;\n          var a = -(e.start.dot(this.normal) + this.constant) / r;\n          return a < 0 || a > 1 ? void 0 : n.copy(o).multiplyScalar(a).add(e.start);\n        };\n      }(),\n      intersectPlane: function (t) {\n        var e = this.normal.clone().cross(t.normal),\n            i = {\n          origin: new s.default(),\n          direction: e\n        };\n        if (this.normal.clone().cross(t.normal).length < 1e-10) return i.direction = new s.default(), i;\n        var n = this.constant,\n            o = t.constant,\n            r = this.normal.clone().dot(t.normal),\n            a = -(n - o * r) / (1 - r * r),\n            h = -(o - n * r) / (1 - r * r);\n        return i.origin = this.normal.clone().multiplyScalar(a).add(t.normal.clone().multiplyScalar(h)), i;\n      },\n      coplanarPoint: function (t) {\n        return (t || new s.default()).copy(this.normal).multiplyScalar(-this.constant);\n      },\n      translate: function (t) {\n        return this.constant = this.constant - t.dot(this.normal), this;\n      },\n      equals: function (t) {\n        return t.normal.equals(this.normal) && t.constant === this.constant;\n      },\n      clone: function () {\n        return new h().copy(this);\n      }\n    }, e.default = h;\n  }, function (t, e, i) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n    var n,\n        o = i(1),\n        s = (n = o) && n.__esModule ? n : {\n      default: n\n    };\n\n    var r = function (t, e, i, n, o, s, r, a, h, u, c, l, f, y, d, p) {\n      this.elements = new Float32Array(16);\n      var x = this.elements;\n      x[0] = void 0 !== t ? t : 1, x[4] = e || 0, x[8] = i || 0, x[12] = n || 0, x[1] = o || 0, x[5] = void 0 !== s ? s : 1, x[9] = r || 0, x[13] = a || 0, x[2] = h || 0, x[6] = u || 0, x[10] = void 0 !== c ? c : 1, x[14] = l || 0, x[3] = f || 0, x[7] = y || 0, x[11] = d || 0, x[15] = void 0 !== p ? p : 1;\n    };\n\n    r.prototype.makeRotationFromQuaternion = function (t) {\n      var e = this.elements,\n          i = t.x,\n          n = t.y,\n          o = t.z,\n          s = t.w,\n          r = i + i,\n          a = n + n,\n          h = o + o,\n          u = i * r,\n          c = i * a,\n          l = i * h,\n          f = n * a,\n          y = n * h,\n          d = o * h,\n          p = s * r,\n          x = s * a,\n          m = s * h;\n      return e[0] = 1 - (f + d), e[4] = c - m, e[8] = l + x, e[1] = c + m, e[5] = 1 - (u + d), e[9] = y - p, e[2] = l - x, e[6] = y + p, e[10] = 1 - (u + f), e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;\n    }, r.prototype.multiplyMatrices = function (t, e) {\n      var i = t.elements,\n          n = e.elements,\n          o = this.elements,\n          s = i[0],\n          r = i[4],\n          a = i[8],\n          h = i[12],\n          u = i[1],\n          c = i[5],\n          l = i[9],\n          f = i[13],\n          y = i[2],\n          d = i[6],\n          p = i[10],\n          x = i[14],\n          m = i[3],\n          v = i[7],\n          g = i[11],\n          z = i[15],\n          b = n[0],\n          M = n[4],\n          w = n[8],\n          R = n[12],\n          P = n[1],\n          L = n[5],\n          T = n[9],\n          S = n[13],\n          _ = n[2],\n          V = n[6],\n          q = n[10],\n          j = n[14],\n          E = n[3],\n          k = n[7],\n          O = n[11],\n          A = n[15];\n      return o[0] = s * b + r * P + a * _ + h * E, o[4] = s * M + r * L + a * V + h * k, o[8] = s * w + r * T + a * q + h * O, o[12] = s * R + r * S + a * j + h * A, o[1] = u * b + c * P + l * _ + f * E, o[5] = u * M + c * L + l * V + f * k, o[9] = u * w + c * T + l * q + f * O, o[13] = u * R + c * S + l * j + f * A, o[2] = y * b + d * P + p * _ + x * E, o[6] = y * M + d * L + p * V + x * k, o[10] = y * w + d * T + p * q + x * O, o[14] = y * R + d * S + p * j + x * A, o[3] = m * b + v * P + g * _ + z * E, o[7] = m * M + v * L + g * V + z * k, o[11] = m * w + v * T + g * q + z * O, o[15] = m * R + v * S + g * j + z * A, this;\n    }, r.prototype.multiply = function (t, e) {\n      return void 0 !== e ? (console.warn(\"DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.\"), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t);\n    }, r.prototype.getInverse = function (t, e) {\n      var i = this.elements,\n          n = t.elements,\n          o = n[0],\n          s = n[4],\n          r = n[8],\n          a = n[12],\n          h = n[1],\n          u = n[5],\n          c = n[9],\n          l = n[13],\n          f = n[2],\n          y = n[6],\n          d = n[10],\n          p = n[14],\n          x = n[3],\n          m = n[7],\n          v = n[11],\n          g = n[15];\n      i[0] = c * p * m - l * d * m + l * y * v - u * p * v - c * y * g + u * d * g, i[4] = a * d * m - r * p * m - a * y * v + s * p * v + r * y * g - s * d * g, i[8] = r * l * m - a * c * m + a * u * v - s * l * v - r * u * g + s * c * g, i[12] = a * c * y - r * l * y - a * u * d + s * l * d + r * u * p - s * c * p, i[1] = l * d * x - c * p * x - l * f * v + h * p * v + c * f * g - h * d * g, i[5] = r * p * x - a * d * x + a * f * v - o * p * v - r * f * g + o * d * g, i[9] = a * c * x - r * l * x - a * h * v + o * l * v + r * h * g - o * c * g, i[13] = r * l * f - a * c * f + a * h * d - o * l * d - r * h * p + o * c * p, i[2] = u * p * x - l * y * x + l * f * m - h * p * m - u * f * g + h * y * g, i[6] = a * y * x - s * p * x - a * f * m + o * p * m + s * f * g - o * y * g, i[10] = s * l * x - a * u * x + a * h * m - o * l * m - s * h * g + o * u * g, i[14] = a * u * f - s * l * f - a * h * y + o * l * y + s * h * p - o * u * p, i[3] = c * y * x - u * d * x - c * f * m + h * d * m + u * f * v - h * y * v, i[7] = s * d * x - r * y * x + r * f * m - o * d * m - s * f * v + o * y * v, i[11] = r * u * x - s * c * x - r * h * m + o * c * m + s * h * v - o * u * v, i[15] = s * c * f - r * u * f + r * h * y - o * c * y - s * h * d + o * u * d;\n      var z = o * i[0] + h * i[4] + f * i[8] + x * i[12];\n\n      if (0 === z) {\n        var b = \"Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n        if (e) throw new Error(b);\n        return console.warn(b), this.identity(), this;\n      }\n\n      return this.multiplyScalar(1 / z), this;\n    }, r.prototype.applyToVector3Array = function () {\n      var t = new s.default();\n      return function (e, i, n) {\n        void 0 === i && (i = 0), void 0 === n && (n = e.length);\n\n        for (var o = 0, s = i; o < n; o += 3, s += 3) t.x = e[s], t.y = e[s + 1], t.z = e[s + 2], t.applyMatrix4(this), e[s] = t.x, e[s + 1] = t.y, e[s + 2] = t.z;\n\n        return e;\n      };\n    }, r.prototype.makeTranslation = function (t, e, i) {\n      return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;\n    }, r.prototype.multiplyScalar = function (t) {\n      var e = this.elements;\n      return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;\n    }, r.prototype.set = function (t, e, i, n, o, s, r, a, h, u, c, l, f, y, d, p) {\n      var x = this.elements;\n      return x[0] = t, x[4] = e, x[8] = i, x[12] = n, x[1] = o, x[5] = s, x[9] = r, x[13] = a, x[2] = h, x[6] = u, x[10] = c, x[14] = l, x[3] = f, x[7] = y, x[11] = d, x[15] = p, this;\n    }, r.prototype.makeScale = function (t, e, i) {\n      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;\n    }, e.default = r;\n  }, function (t, e, i) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var n,\n        o = function () {\n      function t(t, e) {\n        for (var i = 0; i < e.length; i++) {\n          var n = e[i];\n          n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n        }\n      }\n\n      return function (e, i, n) {\n        return i && t(e.prototype, i), n && t(e, n), e;\n      };\n    }(),\n        s = i(1),\n        r = (n = s) && n.__esModule ? n : {\n      default: n\n    },\n        a = i(0);\n\n    var h = function () {\n      function t(e, i) {\n        !function (t, e) {\n          if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, t), this.start = void 0 !== e ? e : new r.default(), this.end = void 0 !== i ? i : new r.default();\n      }\n\n      return o(t, [{\n        key: \"set\",\n        value: function (t, e) {\n          return this.start.copy(t), this.end.copy(e), this;\n        }\n      }, {\n        key: \"copy\",\n        value: function (t) {\n          return this.start.copy(t.start), this.end.copy(t.end), this;\n        }\n      }, {\n        key: \"center\",\n        value: function (t) {\n          return (t || new r.default()).addVectors(this.start, this.end).multiplyScalar(.5);\n        }\n      }, {\n        key: \"delta\",\n        value: function (t) {\n          return (t || new r.default()).subVectors(this.end, this.start);\n        }\n      }, {\n        key: \"distanceSq\",\n        value: function () {\n          return this.start.distanceToSquared(this.end);\n        }\n      }, {\n        key: \"distance\",\n        value: function () {\n          return this.start.distanceTo(this.end);\n        }\n      }, {\n        key: \"at\",\n        value: function (t, e) {\n          var i = e || new r.default();\n          return this.delta(i).multiplyScalar(t).add(this.start);\n        }\n      }, {\n        key: \"closestPointToPointParameter\",\n        value: function (t, e) {\n          var i = new r.default(),\n              n = new r.default();\n          i.subVectors(t, this.start), n.subVectors(this.end, this.start);\n          var o = n.dot(n),\n              s = n.dot(i) / o;\n          return e && (s = (0, a.clamp)(s, 0, 1)), s;\n        }\n      }, {\n        key: \"closestPointToPoint\",\n        value: function (t, e, i) {\n          var n = this.closestPointToPointParameter(t, e),\n              o = i || new r.default();\n          return this.delta(o).multiplyScalar(n).add(this.start);\n        }\n      }, {\n        key: \"applyMatrix4\",\n        value: function (t) {\n          return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;\n        }\n      }, {\n        key: \"equals\",\n        value: function (t) {\n          return t.start.equals(this.start) && t.end.equals(this.end);\n        }\n      }, {\n        key: \"clone\",\n        value: function () {\n          return new t().copy(this);\n        }\n      }, {\n        key: \"intersectLine\",\n        value: function (t) {\n          var e = this.end.clone().sub(this.start),\n              i = t.end.clone().sub(t.start),\n              n = t.start.clone().sub(this.start),\n              o = e.clone().cross(i),\n              s = n.clone().cross(i);\n\n          if (0 !== n.dot(e)) {\n            var r = s.dot(o) / o.lengthSq();\n\n            if (!(r > 1 || isNaN(r))) {\n              var a = this.start.clone().add(e.clone().multiplyScalar(r));\n              return a.clone().sub(t.start).lengthSq() + a.clone().sub(t.end).lengthSq() <= t.distanceSq() ? a : void 0;\n            }\n          }\n        }\n      }]), t;\n    }();\n\n    e.default = h;\n  }, function (t, e, i) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.Vector3 = e.rect = e.quaternion = e.point = e.Plane = e.Matrix4 = e.sign = e.radToDeg = e.degToRad = e.clamp = e.lineSegment = e.Line3 = void 0;\n    var n = f(i(8)),\n        o = f(i(2)),\n        s = i(0),\n        r = f(i(7)),\n        a = f(i(6)),\n        h = f(i(5)),\n        u = f(i(3)),\n        c = f(i(4)),\n        l = f(i(1));\n\n    function f(t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    }\n\n    var y = {\n      Line3: n.default,\n      lineSegment: o.default,\n      clamp: s.clamp,\n      degToRad: s.degToRad,\n      radToDeg: s.radToDeg,\n      sign: s.sign,\n      Matrix4: r.default,\n      Plane: a.default,\n      point: h.default,\n      quaternion: u.default,\n      rect: c.default,\n      Vector3: l.default\n    };\n    e.Line3 = n.default, e.lineSegment = o.default, e.clamp = s.clamp, e.degToRad = s.degToRad, e.radToDeg = s.radToDeg, e.sign = s.sign, e.Matrix4 = r.default, e.Plane = a.default, e.point = h.default, e.quaternion = u.default, e.rect = c.default, e.Vector3 = l.default, e.default = y;\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}