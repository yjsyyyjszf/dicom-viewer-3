{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.deserialize = deserialize;\nexports.serialize = serialize;\nexports.readFileSync = readFileSync;\nexports.writeFileSync = writeFileSync;\nexports.default = void 0;\n\nfunction _fs() {\n  const data = _interopRequireDefault(require('fs'));\n\n  _fs = function _fs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _v() {\n  const data = _interopRequireDefault(require('v8'));\n\n  _v = function _v() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// TODO: Remove this\n/// <reference path=\"../v8.d.ts\" />\n// JSON and V8 serializers are both stable when it comes to compatibility. The\n// current JSON specification is well defined in RFC 8259, and V8 ensures that\n// the versions are compatible by encoding the serialization version in the own\n// generated buffer.\n\n\nconst JS_TYPE = '__$t__';\nconst JS_VALUE = '__$v__';\nconst JS_VF = '__$f__';\n\nfunction replacer(_key, value) {\n  // NaN cannot be in a switch statement, because NaN !== NaN.\n  if (Number.isNaN(value)) {\n    return {\n      [JS_TYPE]: 'n'\n    };\n  }\n\n  switch (value) {\n    case undefined:\n      return {\n        [JS_TYPE]: 'u'\n      };\n\n    case +Infinity:\n      return {\n        [JS_TYPE]: '+'\n      };\n\n    case -Infinity:\n      return {\n        [JS_TYPE]: '-'\n      };\n  }\n\n  switch (value && value.constructor) {\n    case Date:\n      return {\n        [JS_TYPE]: 'd',\n        [JS_VALUE]: value.getTime()\n      };\n\n    case RegExp:\n      return {\n        [JS_TYPE]: 'r',\n        [JS_VALUE]: value.source,\n        [JS_VF]: value.flags\n      };\n\n    case Set:\n      return {\n        [JS_TYPE]: 's',\n        [JS_VALUE]: Array.from(value)\n      };\n\n    case Map:\n      return {\n        [JS_TYPE]: 'm',\n        [JS_VALUE]: Array.from(value)\n      };\n\n    case Buffer:\n      return {\n        [JS_TYPE]: 'b',\n        [JS_VALUE]: value.toString('latin1')\n      };\n  }\n\n  return value;\n}\n\nfunction reviver(_key, value) {\n  if (!value || typeof value !== 'object' && !value.hasOwnProperty(JS_TYPE)) {\n    return value;\n  }\n\n  switch (value[JS_TYPE]) {\n    case 'u':\n      return undefined;\n\n    case 'n':\n      return NaN;\n\n    case '+':\n      return +Infinity;\n\n    case '-':\n      return -Infinity;\n\n    case 'd':\n      return new Date(value[JS_VALUE]);\n\n    case 'r':\n      return new RegExp(value[JS_VALUE], value[JS_VF]);\n\n    case 's':\n      return new Set(value[JS_VALUE]);\n\n    case 'm':\n      return new Map(value[JS_VALUE]);\n\n    case 'b':\n      return Buffer.from(value[JS_VALUE], 'latin1');\n  }\n\n  return value;\n}\n\nfunction jsonStringify(content) {\n  // Not pretty, but the ES JSON spec says that \"toJSON\" will be called before\n  // getting into your replacer, so we have to remove them beforehand. See\n  // https://www.ecma-international.org/ecma-262/#sec-serializejsonproperty\n  // section 2.b for more information.\n  const dateToJSON = Date.prototype.toJSON;\n  const bufferToJSON = Buffer.prototype.toJSON;\n  /* eslint-disable no-extend-native */\n\n  try {\n    // @ts-ignore intentional removal of \"toJSON\" property.\n    Date.prototype.toJSON = undefined; // @ts-ignore intentional removal of \"toJSON\" property.\n\n    Buffer.prototype.toJSON = undefined;\n    return JSON.stringify(content, replacer);\n  } finally {\n    Date.prototype.toJSON = dateToJSON;\n    Buffer.prototype.toJSON = bufferToJSON;\n  }\n  /* eslint-enable no-extend-native */\n\n}\n\nfunction jsonParse(content) {\n  return JSON.parse(content, reviver);\n} // In memory functions.\n\n\nfunction deserialize(buffer) {\n  return _v().default.deserialize ? _v().default.deserialize(buffer) : jsonParse(buffer.toString('utf8'));\n}\n\nfunction serialize(content) {\n  return _v().default.serialize ? _v().default.serialize(content) : Buffer.from(jsonStringify(content));\n} // Synchronous filesystem functions.\n\n\nfunction readFileSync(filePath) {\n  return _v().default.deserialize ? _v().default.deserialize(_fs().default.readFileSync(filePath)) : jsonParse(_fs().default.readFileSync(filePath, 'utf8'));\n}\n\nfunction writeFileSync(filePath, content) {\n  return _v().default.serialize ? _fs().default.writeFileSync(filePath, _v().default.serialize(content)) : _fs().default.writeFileSync(filePath, jsonStringify(content), 'utf8');\n}\n\nvar _default = {\n  deserialize,\n  readFileSync,\n  serialize,\n  writeFileSync\n};\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}